<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Robin Suter">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>AD2 - HSR Notizen</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  <link href="../../extra.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "AD2";
    var mkdocs_page_input_path = "hs16/ad2.md";
    var mkdocs_page_url = "/hs16/ad2/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> HSR Notizen</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">Home</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>HS16</span></li>

        
            
    <li class="toctree-l1 current">
        <a class="current" href="./">AD2</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#algorithmen-und-datenstrukturen-2">Algorithmen und Datenstrukturen 2</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-1-binary-search-tree">Vorlesung 1 - Binary Search Tree</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-2-avl-trees-1">Vorlesung 2 - AVL-Trees (1)</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-4-splay-trees-merge-sort">Vorlesung 4 - Splay-Trees / Merge-Sort</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-5-quick-sort">Vorlesung 5 - Quick-Sort</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-6-radix-sort-pattern-matching">Vorlesung 6 - Radix-Sort / Pattern Matching</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-8-tries">Vorlesung 8 - Tries</a></li>
                
            
                <li class="toctree-l3"><a href="#vorlesung-9-dynamische-programmierung">Vorlesung 9 - Dynamische Programmierung</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-10-graphen-1">Vorlesung 10 - Graphen (1)</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-11-graphen-2">Vorlesung 11 - Graphen (2)</a></li>
                
            
            </ul>
        
    </li>

        
            
    <ul class="subnav">
    <li><span>BuRe1</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../reing/">ReIng</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../bupl/">BuPl</a>
        
    </li>

        
    </ul>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../cpi/">C++</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../englhtw/">EnglHTw</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../mge/">MGE</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../mste/">MsTe</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../se1/">SE1</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../wed2/">WED2</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../playground/">Playground</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">HSR Notizen</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>HS16 &raquo;</li>
        
      
    
    <li>AD2</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/Excape/hsr-docs-hs16/edit/master/docs/hs16/ad2.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="algorithmen-und-datenstrukturen-2">Algorithmen und Datenstrukturen 2</h1>
<ul>
<li>Visualisierungen: <a href="http://visualgo.net/">http://visualgo.net/</a></li>
</ul>
<h2 id="vorlesung-1-binary-search-tree">Vorlesung 1 - Binary Search Tree</h2>
<ul>
<li>Ein Heap hat das kleinste oder grösste Element als Root</li>
<li>Eine Suche auf einem Heap würde mit <script type="math/tex">O(n)</script> laufen, da man nicht weiss, welches Child jeweils kleiner / grösser ist</li>
<li>
<p>Multimaps: Pro Key sind mehrere Values erlaubt</p>
</li>
<li>
<p><strong>Folie 5</strong><br />
Voraussetzung: Random Access, Daten müssen sortiert sein</p>
</li>
<li>
<p><strong>Folie 6</strong> </p>
<ul>
<li>Insert: Finden der richtigen Position: <script type="math/tex">O(log(n))</script>, Rest verschieben: <script type="math/tex">O(n)</script>
</li>
<li>Remove gleich wie Insert</li>
</ul>
</li>
<li>
<p><strong>Folie 7</strong>  </p>
<ul>
<li>Der Baum muss so aufgebaut sein, dass der linke Child-Knoten immer &lt;= Parent-Node ist</li>
<li>Externe Knoten speichern keine Daten. Wenn man beim Suchen einen Blattknoten erreicht, ist der Key nicht gefunden</li>
<li>Eine Inorder Traversierung besucht die Keys in aufsteigender Reihenfolge</li>
</ul>
</li>
<li>
<p><strong>Einfügen</strong>  </p>
<ul>
<li>Suchen nach dem einzufügenden Key</li>
<li>Man wird auf einen "Sentinel" external Node treffen</li>
<li>Dort den neuen Key einfügen und in einen internen Knoten umwandeln</li>
<li>Bei einer <em>Multimap</em> kann es mehrere gleiche Keys geben. Dann:<ul>
<li>find, bis man auf den Knoten trifft</li>
<li>nach links weiter suchen bis man auf einen external Node trifft</li>
<li>Dort einfügen und in internen Node umwandeln</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Löschen</strong>  </p>
<ul>
<li>Knoten hat zwei Blatt-Kinder:<ul>
<li>Lösche v und sein linkes Child, rechtes Child rutscht nach oben</li>
</ul>
</li>
<li>Knoten hat ein Blatt-Kind:<ul>
<li>Lösche v und den Blatt-Knoten (links oder rechts), der andere Knoten (mit einem Key) rutscht nach oben</li>
</ul>
</li>
<li>Knoten hat keine Blatt-Kinder:<ul>
<li>Finde den Knoten <code>w</code>, der <code>v</code> in der Inorder-Traversierung folgt ("links unten des rechten Teilbaums von <code>v</code>")</li>
<li>Kopiere den Key von <code>w</code> zu <code>V</code></li>
<li>Lösche <code>w</code> mit dem gleichen Algorithmus wie bei Fall 1 und 2</li>
</ul>
</li>
<li><em>Für die ersten beiden Fälle ist der Algorithmus derselbe</em></li>
</ul>
</li>
<li>
<p><strong>Performance</strong>  </p>
<ul>
<li>Worst Case: Komplett unbalancierter Baum (z.B. Einfügen mit <em>sortiertem</em> Input). Höhe ist <script type="math/tex">O(n)</script>. Dann ist es eine Linked-List</li>
<li>Best Case: Mit der Mitte beginnen, komplett Balanciert.</li>
<li>Höhe <script type="math/tex">log(n)</script>
</li>
<li>Balanciert sich nicht selbst (wie andere Bäume, s. später)</li>
</ul>
</li>
<li><strong>Implementierung</strong><ul>
<li>Hier haben die Attribute der Klasse <code>Knoten</code> die Visibility <code>package</code>, d.h es kann direkt darauf zugegriffen werden</li>
<li>Einfügen: Map (nicht Multimap). Wenn der Key schon vorhanden ist, bleibt er einfach bestehen (key wird zurück gegeben)</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-2-avl-trees-1">Vorlesung 2 - AVL-Trees (1)</h2>
<p>Bei einem AVL Tree muss für jeden Teilbaum gelten, dass die Kinder maximal einen Höhenunterschied von 1 haben.</p>
<p>Beweis: Jeder AVL-Baum mit minimalen Anzahl Knoten <script type="math/tex">n</script> bei Höhe <script type="math/tex">h</script> hat einen linken und rechten Teilbaum. Der eine Teilbaum hat Höhe <script type="math/tex">h - 1</script> und der rechte <script type="math/tex">h - 2</script>
</p>
<p>
<script type="math/tex; mode=display">n(h) = 1 + n(h-1) + n(h-2)</script>
<script type="math/tex; mode=display">n(h) > 2n(h-2)</script>
<script type="math/tex; mode=display">n(h-2) = 1 + n(h-3) + n(h-4)</script>
<script type="math/tex; mode=display">n(h-2) > 2n(h-4)</script>
<script type="math/tex; mode=display">n(h) > 4n(h-4)</script>
<script type="math/tex; mode=display">n(h-4) = 1 + n(h-5) + n(h-6)</script>
<script type="math/tex; mode=display">n(h-4) > 2n(h-6)</script>
<script type="math/tex; mode=display">n(h) > 8n(h-6)</script>
<script type="math/tex; mode=display">\ldots</script>
<script type="math/tex; mode=display">n(h) > 16n(h-8)</script>
<script type="math/tex; mode=display">n(h) > 2^i n(h-2i)</script>
</p>
<p>
<script type="math/tex; mode=display">n_{min}(h=1) = 1</script>
<script type="math/tex; mode=display">n_{min}(h=2) = 2</script>
</p>
<p>
<script type="math/tex; mode=display">i: h-2i = (1 | 2)</script>
<script type="math/tex; mode=display">h = (1 | 2) + 2i</script>
<script type="math/tex; mode=display">\text{bsp.:}</script>
<script type="math/tex; mode=display">i = 1 : h = 3 | 4</script>
<script type="math/tex; mode=display">i = 2 : h = 5 | 6</script>
<script type="math/tex; mode=display">i = 3 : h = 7 | 8</script>
<script type="math/tex; mode=display"> i = \frac h2 - 1 \text{ wobei h/2 gerundet}</script>
Einsetzen in <script type="math/tex">n(h) > 2^i n(h-2i)</script>:
<script type="math/tex; mode=display">n > 2^{\frac h2 - 1} \cdot (1 | 2)</script>
Konstanten heraus streichen:
<script type="math/tex; mode=display">n > 2^{\frac h2-1}</script>
<script type="math/tex; mode=display">log(n) > \frac h2 - 1</script>
<script type="math/tex; mode=display">h < 2\cdot log(n) + 2</script>
<script type="math/tex; mode=display">\rightarrow h \in O(log(n))</script>
</p>
<ul>
<li>Einfügen:<ul>
<li>Den neuen Knoten wie bei einem BST einfügen</li>
<li>Prüfen, ob AVL-Bedingungen verletzt wurden</li>
<li>Aus dem neuen Knoten aus solange nach oben wandern, bis man auf einen Eltern-Knoten eines unbalancierten Teilbaums trifft</li>
</ul>
</li>
<li>Umstrukturierung:<ul>
<li>x, y, z: Aufgrund des Suchpfades Kind, Eltern, Grosseltern</li>
<li>a, b, c: Inorder-Reihenfolge</li>
<li>Wenn es von x bis z nur in eine Richtung geht: Rotation um b (= y)</li>
<li>Bei Richtungsänderung von x bis z:<ul>
<li>Zuerst den Teilbaum b und c (x und y) rotieren, so dass a, b, c wieder in einer Richtung ist wie oben</li>
<li>Wieder wie oben um b rotieren</li>
</ul>
</li>
<li><em>(Tipp:)</em> Jeweils nach Rotation mit Inorder Traversierung prüfen</li>
<li>Eine Restrukturierung mit Cut/Link muss nicht den gleichen Baum ergeben wie mit dem Rotationsverfahren!</li>
</ul>
</li>
<li>Löschen<ul>
<li>Löschen wie bei BST</li>
<li>Die Balance kann verletzt werden</li>
<li>Die Knoten x, y, z sollten im höheren Teilbaum sein (beim Einfügen automatisch gegeben)</li>
<li>Nach dem Restrukturierung kann eine neue Unbalance entstehen! (Im Gegensatz zum Einfügen). Man muss bis zur Root weiter nach Unbalancierten Teilbäumen suchen</li>
</ul>
</li>
<li>Implementierung<ul>
<li>Mit einer AVL-Node wird dessen Höhe gespeichert</li>
<li>actionPos: Die Position, in der etwas passiert ist (z.B. letzte Einfügeposition). Ist ein Attribut der BST-Klasse</li>
<li>Nach dem Einfügen wird die (BST-)Node (Item) mit einer Instanz von AVLItem ersetzt</li>
<li>Besser: Funktion newNode() des BST überschreiben</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-4-splay-trees-merge-sort">Vorlesung 4 - Splay-Trees / Merge-Sort</h2>
<h3 id="splay-trees">Splay-Trees</h3>
<ul>
<li>Nach dem Einfügen ist der eingefügte Knoten immer Root</li>
<li>Beim Suchen wird der Baum auch restrukturiert, der gesuchte Knoten ist danach Root</li>
<li>Knoten mit gleichem Wert können weit auseinander sein</li>
<li>Suchen gleich wie bei BST</li>
<li>Muss nicht Balanced sein wie AVL!</li>
</ul>
<h4 id="splay-operation">Splay-Operation</h4>
<ul>
<li>Wird nach <em>jeder</em> Operation (auch Suchen) ausgeführt</li>
<li>rechts und links Rotation gleich wie bei AV"L</li>
<li>"zig" -&gt; linkes Kind, "zag" -&gt; rechtes Kind</li>
<li>x: betroffener Knoten, y: parent von x, z: parent-parent von x</li>
<li>Rotationen solange wiederholen, bis x Root wird</li>
</ul>
<h4 id="loschen">Löschen</h4>
<ul>
<li>Wie bei BST</li>
<li>Bei "Fall 3": Ersetze Knoten durch inorder-Nachfolger</li>
<li>Splayen mit tiefstem internem <em>zugegriffenem</em> Knoten (Elternknoten des gelöschten)</li>
</ul>
<h4 id="performance">Performance</h4>
<ul>
<li>Splaying: <script type="math/tex">O(h)</script>
<ul>
<li>Durchschnittlich <script type="math/tex">O(logn)</script>
</li>
<li>Worst case ist Höhe h = n, d.h. <script type="math/tex">O(n)</script>
</li>
</ul>
</li>
<li>Oft besuchte Knoten kommen immer näher an die Root, d.h es wird schneller</li>
<li>Anwendung z.B. bei Suchmaschinen</li>
</ul>
<h4 id="splay-entscheid">Splay-Entscheid</h4>
<ul>
<li>Wenn mit find() nicht gefunden wird, der letzte gefunden Knoten nehmen</li>
</ul>
<h3 id="merge-sort">Merge-Sort</h3>
<ul>
<li>Divide and Conquer Prinzip<ul>
<li>Daten in zwei Teilmengen aufteilen</li>
<li>Problem rekursiv für beide Teilmengen lösen</li>
<li>Conquer: Lösungen mischen</li>
<li>Verankerung ist Inputgrösse 1 oder 0</li>
</ul>
</li>
<li>Merge-Sort sortiert Rekursiv die halbe Menge und "merged" die beiden sortierten Teilmengen zusammen</li>
<li>Merge()<ul>
<li>Beide Listen von vorne her leeren</li>
<li>Wenn A kleiner ist, A in S einfügen, sonst B in S einfügen</li>
<li>wenn eine Liste leer, der Rest der anderen an S anfügen</li>
<li>
<script type="math/tex">O(n)</script> mit double-linked-List</li>
</ul>
</li>
<li>Performance<ul>
<li>Die Höhe des Rerkursionsbaums ist <script type="math/tex">O(log n)</script>
</li>
<li>Jede Rekursion braucht <script type="math/tex">O(n)</script>
</li>
<li>Total <script type="math/tex">O(n log n)</script>
</li>
</ul>
</li>
<li>Java.util.sort ist ein modifizierter Merge-Sort<ul>
<li>Wenn das grösste Element der ersten Liste kleiner als das kleinste Element der zweiten Liste ist, kann man einfach die beiden Listen aneinander hängen (keine Vergleiche nötig)</li>
<li>Garantiert <script type="math/tex">O(n log n)</script>
</li>
</ul>
</li>
</ul>
<p><img alt="Vergleich Sortieralgorithmen" src="../img/sort_vergleiche.png" /></p>
<ul>
<li>Implementierung nicht-rekursiv<ul>
<li>mit i = 1: Zweier-Pärchen sortieren und in out schreiben</li>
<li>in und out swappen</li>
<li>Nun Vierer-Gruppen (zwei Pärchen) sortiert in out schreiben</li>
<li>in und out swappen</li>
<li>usw... Es wird immer verdoppelt</li>
<li>Quasi im rekurvis-Baum "Bottom up"</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-5-quick-sort">Vorlesung 5 - Quick-Sort</h2>
<ul>
<li>Vergleich Insertion-Sort (<script type="math/tex">O(n^2)</script>) und Merge-Sort (<script type="math/tex">O(n log n)): Bei \(2^{14}</script> Elementen ist Merge-Sort 100x schneller, bei 1 Mio. Elementen ist es 6'400x schneller</li>
<li>Insertion Sort würde für 1 Mio. Elemente ca. 1h 47' benötigen, merge-Sort nur einige Sekunden</li>
</ul>
<h3 id="quick-sort">Quick-Sort</h3>
<ul>
<li>Partitionierung in 3 Mengen: Less, Equal und Greater mit einem Pivot x<ul>
<li>Jedes Element in die richtige Menge kopieren -&gt; <script type="math/tex">O(n)</script>
</li>
</ul>
</li>
<li>Rekursiver Aufruf mit L und G</li>
<li>Zusammensetzen: L, E, G hintereinander wieder einfügen</li>
</ul>
<p><img alt="Vergleich Sortieralgorithmen" src="../img/quicksort_tree.png" /></p>
<ul>
<li>Wenn der Pivot immer das minimum oder maximum ist, gibt es einen einseitigen "tree", d.h Worst-Case ist <script type="math/tex">O(n^2)</script>
</li>
<li>Der optimale Pivot wäre der mittlere Wert</li>
<li>Wenn die Daten normalverteilt sind, gibt es zu 50% "bad-calls" bei zufälliger Wahl des Pivots (1. und 4. Viertel)</li>
<li>Erwartet wird ein Baum mit Höhe <script type="math/tex">log n</script>. Jedes Level benötigt <script type="math/tex">O(n)</script>, also total <script type="math/tex">O(n log n)</script>
</li>
<li>In-Place Quicksort<ul>
<li>Worst-Case: Wenn die Liste bereits sortiert ist</li>
</ul>
</li>
</ul>
<h3 id="sorting-lower-bound">Sorting Lower Bound</h3>
<ul>
<li>Jede Permutation von Daten zeigt einen Pfad durch den Entscheidungsbaum</li>
<li>Das gibt n! Permutationen, also ist die Höhe des Baumes log(n!)
<script type="math/tex; mode=display">n^n > n! > {\frac n2}^{\frac n2}</script>
</li>
<li>Die Untere Grenze für <em>Vergleichs</em>algorithmen ist <script type="math/tex">O(n log(n))</script>
</li>
</ul>
<h3 id="bucket-sort">Bucket-Sort</h3>
<ul>
<li>Eine Sequenz mit Key-Value-Paaren</li>
<li>Jedes Item in ein Array mit dem Key als Index kopieren<ul>
<li>Genauer ein Array von Listen, Elemente mit gleichem Key werden der Liste angehängt</li>
</ul>
</li>
<li>Array durch iterieren und der Reihe nach ausgeben</li>
<li>Laufzeit: <script type="math/tex">O(n + N)</script>, wobei N der grösstmögliche Wert der Keys ist<ul>
<li>Kein Widerspruch zu oben, weil Algorithmus nicht vergleichs-basiert ist</li>
</ul>
</li>
<li>Eingeschränkt auf ganze, positive Zahlen</li>
<li><em>Stabile</em> Sort-Eigenschaft: die relative Ordnung von Items mit gleichem Wert wird nicht verändert</li>
</ul>
<hr />
<h2 id="vorlesung-6-radix-sort-pattern-matching">Vorlesung 6 - Radix-Sort / Pattern Matching</h2>
<h3 id="lexikographische-sortierung">Lexikographische Sortierung</h3>
<ul>
<li>Die letzte Dimension wird <em>zuletzt</em> sortiert, d.h die Dimension mit 1. Priorität am Schluss</li>
<li>Einfachste Anwendung ist mit Strings</li>
<li>Radix-Sort<ul>
<li>Lexikographische Sortierung mit Bucket-Sort</li>
</ul>
</li>
</ul>
<h3 id="pattern-matching">Pattern Matching</h3>
<ul>
<li>Ziel: In einer Sequenz von Zeichen ein Pattern finden</li>
<li>Substring wird hier inklusive end-index angegeben. In Java geht der Substring bis endIndex - 1!</li>
<li>Brute-Force-Methode<ul>
<li>Pattern am Anfang des Textes ansetzen und Zeichen für Zeichen durchlaufen bis zum Ende</li>
<li>Bei jeder Iteration prüfen, ob das Pattern übereinstimmt</li>
<li>Performance: Pattern m n Mal durchsuchen -&gt; <script type="math/tex">O(n\cdot m)</script>
</li>
</ul>
</li>
<li>Boyer-Moore Heuristik<ul>
<li>"Looking Glass": Starte jeweils am Ende des Patterns</li>
<li>"Character Jump": Bei einem Mismatch wird mit dem Pattern an die nächstmögliche Position gesprungen, wo das Zeichen im Text im Pattern vorkommt (wenn nicht, kann es gleich weiter geschoben werden um ganze Patternlänge)<ul>
<li>Es muss zwinged auf das letzt auftretende (möglichst weit rechte) Zeichen ausgerichtet werden</li>
<li>Wenn man dabei nach links schieben würde, wird stattdessen um 1 nach rechts geschoben</li>
</ul>
</li>
<li>Die Last Occurence Funktion speichert von jedem zeichen im Alphabet die letzte Position im Pattern (wenn es nicht vorkommt, -1)</li>
<li>Damit kann mit \O(1)) die Anzahl der Verschiebungen berechnet werden</li>
<li>Performance: Im Worst Case <script type="math/tex">O(n\cdot m + s)</script>, also schlechter als Brute Force. Im Durchschnitt ist er aber sehr schnell für Textanalysen</li>
</ul>
</li>
<li>KMP Algorithmus<ul>
<li>Sucht Suffixe, die auch Präfixe vom Pattern sind</li>
<li>So werden nach dem Verschieben nach rechts redundante Vergleiche vermieden</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-8-tries">Vorlesung 8 - Tries</h2>
<ul>
<li>Ziel: Preprocessing vom Text (n), um Suchen in Abhängigkeit von m zu erreichen (statt voher von n)</li>
<li>Ein "Trie" ist ein geordneter Baum, wobei jeder Knoten ausser der Root ein Zeichen hat</li>
<li>Die Strings entstehen vom ersten Child-Knoten bis zu den externen Nodes</li>
<li>Folie 7<ul>
<li>Erster Index ist Index in Wörter-Array S</li>
<li>Zweiter und dritter Index ist Range in diesem String</li>
</ul>
</li>
<li>Mit einem normalen Trie findet man nur komplette Wörter und Präfixe als Matches, keine Suffixe</li>
<li>Dafür für jedes Wort einen Suffix-Trie erstellen<ul>
<li>Jeder mögliche Suffix wird in den Trie eingefügt</li>
<li>Auch substrings werden darin gefunden, da sie präfixe der Suffixe im Suffix-Trie sind</li>
</ul>
</li>
</ul>
<hr />
<h1 id="vorlesung-9-dynamische-programmierung">Vorlesung 9 - Dynamische Programmierung</h1>
<ul>
<li>Rucksack-Problem ist hier nur polynomiell lösbar, weil es ganze Zahlen sind (sonst ist es NP-Vollständig)</li>
<li>Ziel ist immer, Resultate von Subproblemen zu speichern, weil sie Einfluss auf die anderen Lösungen (der Subprobleme) haben</li>
<li>Beispiel Fibonacci: Mit normaler Rekursiver Variante werden die tieferen Fib-Zahlen immer mehrmals berechnen. Viel schneller ist es, die Zwischenergebnisse jeweils in einer Tabelle zu speichern, und nur berechnen, wenn sie noch nicht darin vorkommen.</li>
<li>Beispiel LCS<ul>
<li>Horizontal ist X(m), Vertikal Y(n)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>C</th>
<th>G</th>
<th>A</th>
<th>T</th>
<th>...</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>...</td>
</tr>
<tr>
<td>T</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>...</td>
</tr>
<tr>
<td>T</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="vorlesung-10-graphen-1">Vorlesung 10 - Graphen (1)</h2>
<ul>
<li>Definition: <code>V</code> ist Set von Vertices, <code>E</code> eine Collection von Vertices-Paaren (=Kanten)<ul>
<li>Kanten und Vertizes speichern Elemente</li>
<li>gerichtet: Kante hat eine Richtung</li>
<li>Gibt auch Graphen, die gerichtete und ungerichtete Kanten mischen (z.B. bei Klassendiagramm)</li>
<li><em>inzident</em>: Kante endet an einem Knoten V</li>
<li>parallele kanten: k(anten, die die gleichen zwei Knoten verbinden</li>
<li>Schleife: Kante von Knoten auf sich selbst</li>
<li>Einfacher Pfad: Jede Kante und Vertices kommt nur einmal vor</li>
<li>Zyklus endet ändert immer in einer Kante (die letzte Verbindung zum Startknoten)</li>
<li>Die Summe der Grade in einem Graph ist immer 2*m (2 * Anzahl Kanten)</li>
<li>Voll vermaschter Graph hat <script type="math/tex">\frac{n(n-1)}2</script> Kanten, das ist die maximal mögliche Anzahl<ul>
<li>Das ist <script type="math/tex">\frac{n(n+1)}2 - n</script>
</li>
</ul>
</li>
</ul>
</li>
<li>In Kanten-Listen-Struktur hat jeweils der Vertex und die Kante eine Referenze auf die Position in der Sequenz. Dies ermöglicht, beim Löschen ein Vertex / eine Kante mit <script type="math/tex">O(1)</script> aus der Liste zu löschen<ul>
<li><code>areAdjacent()</code>, <code>removeVertex()</code> und <code>incidentEdges()</code> brauchen <script type="math/tex">O(m)</script>
</li>
<li>Restliche Operationen <script type="math/tex">O(1)</script>
</li>
</ul>
</li>
<li>Adjazent-Listen Struktur<ul>
<li>Jeder Vertex hat eine Referenz auf eine Liste, die Referenzen auf alle incident Vertices enthält</li>
<li>Die Kanten halten eine Referenz auf eine Position in der Incident-Liste</li>
<li>Beim Löschen eines Vertex müssen die Kanten <em>und</em> die Referenzen in den Incident-Listen gelöscht werden</li>
<li>Laufzeit von <code>removeVertex(v)</code> ist abhängig von der Länge der Incident-Liste, also <script type="math/tex">O(deg(v))</script>
</li>
</ul>
</li>
<li>Adjazenz-Matrix Struktur<ul>
<li>Einfügen ist langsam, da die Matrix vergrössert (=kopiert) werden muss</li>
<li><code>areAdjacent()</code> ist schnell (<script type="math/tex">O(1)</script>), da man direkt die Position in der Matrix abfragen kann</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-11-graphen-2">Vorlesung 11 - Graphen (2)</h2>
<ul>
<li>spanning Subtree: Ein Subgraph, der alle Vertizes des Graphen enthält</li>
<li>Verbundene Komponente: Ein verbundener Subgraph</li>
<li>Tree: Verbundener Graph ohne Zyklen</li>
<li>Forest: Mehrere Trees als Komponente, ohne Zyklen</li>
<li>Spanning Tree: Spanning Subtree, der keine Zyklen enthält</li>
</ul>
<h3 id="depth-first-search">Depth-First Search</h3>
<ul>
<li>Technik zur Traversierung von Graphen</li>
<li>Bestimmt, ob Graph verbunden ist und verbundene Komponenten</li>
<li>Berechnet spanning Forest</li>
<li>Algorithmus: Die Kanten werden mit "Discovery" oder "Back" markiert<ul>
<li>Alle "Discovery"-Kanten beschreiben am Ende einen Spanning Tree</li>
</ul>
</li>
<li>Wenn der äusserste Loop in <code>DFS(g)</code> mehr als einmal ein "unexplored" vertex findet, ist der Graph nicht verbunden</li>
</ul>
<h3 id="breath-first-search">Breath-First Search</h3>
<ul>
<li>Sehr ähnlich zu DFS</li>
<li>Sucht zuerst in die Breite statt in die Tiefe</li>
<li>Besser als DFS, um kurze Pfade zu finden</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../reing/" class="btn btn-neutral float-right" title="ReIng">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../.." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/Excape/hsr-docs-hs16" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../.." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../reing/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../../js/theme.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>

</body>
</html>
