<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="no-js ie6"><![endif]-->
<!--[if IE 7 ]><html class="no-js ie7"><![endif]-->
<!--[if IE 8 ]><html class="no-js ie8"><![endif]-->
<!--[if IE 9 ]><html class="no-js ie9"><![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html class="no-js"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    
      
        <title>AD2 - HSR Notizen</title>
      
      
      
        <link rel="canonical" href="https://doc.robinsuter.ch/hs16/ad2/">
      
      
        <meta name="author" content="Robin Suter">
      
    
    <meta property="og:url" content="https://doc.robinsuter.ch/hs16/ad2/">
    <meta property="og:title" content="HSR Notizen">
    <meta property="og:image" content="https://doc.robinsuter.ch/hs16/ad2//../../">
    <meta name="apple-mobile-web-app-title" content="HSR Notizen">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    
    <link rel="shortcut icon" type="image/x-icon" href="../../assets/images/favicon-e565ddfa3b.ico">
    <link rel="icon" type="image/x-icon" href="../../assets/images/favicon-e565ddfa3b.ico">
    <style>
      @font-face {
      	font-family: 'Icon';
      	src: url('../../assets/fonts/icon.eot?52m981');
      	src: url('../../assets/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
      		   url('../../assets/fonts/icon.woff?52m981')
               format('woff'),
      		   url('../../assets/fonts/icon.ttf?52m981')
               format('truetype'),
      		   url('../../assets/fonts/icon.svg?52m981#icon')
               format('svg');
      	font-weight: normal;
      	font-style: normal;
      }
    </style>
    <link rel="stylesheet" href="../../assets/stylesheets/application-a422ff04cc.css">
    
      <link rel="stylesheet" href="../../assets/stylesheets/palettes-05ab2406df.css">
    
    
      
      
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,700|Roboto+Mono">
      <style>
        body, input {
          font-family: 'Roboto', Helvetica, Arial, sans-serif;
        }
        pre, code {
          font-family: 'Roboto Mono', 'Courier New', 'Courier', monospace;
        }
      </style>
    
    
      <link rel="stylesheet" href="../../extra.css">
    
    <script src="../../assets/javascripts/modernizr-4ab42b99fd.js"></script>
    
  </head>
  
  
  
  <body class="palette-primary-red palette-accent-amber">
    
    <div class="backdrop">
      <div class="backdrop-paper"></div>
    </div>
    <input class="toggle" type="checkbox" id="toggle-drawer">
    <input class="toggle" type="checkbox" id="toggle-search">
    <label class="toggle-button overlay" for="toggle-drawer"></label>
    <header class="header">
      <nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        
          <span class="path">
            
              
                HS16 <i class="icon icon-link"></i>
              
            
          </span>
        
        AD2
      </div>
    </div>
    
      
      <div class="button button-twitter" role="button" aria-label="Twitter">
        <a href="https://twitter.com/robin_suter" title="@robin_suter on Twitter" target="_blank" class="toggle-button icon icon-twitter"></a>
      </div>
    
    
      
      <div class="button button-github" role="button" aria-label="GitHub">
        <a href="https://github.com/excape" title="@excape on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
      </div>
    
    <div class="button button-search" role="button" aria-label="Search">
      <label class="toggle-button icon icon-search" title="Search" for="toggle-search"></label>
    </div>
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
    </header>
    <main class="main">
      
      <div class="drawer">
        <nav aria-label="Navigation">
  
  <a href="/" class="project">
    <div class="banner">
      
      <div class="name">
        <strong>
          HSR Notizen
          <span class="version">
            
          </span>
        </strong>
        
      </div>
    </div>
  </a>
  <div class="scrollable">
    <div class="wrapper">
      
      <div class="toc">
        <ul>
          
            
  <li>
    <a class="" title="Home" href="../..">
      Home
    </a>
    
  </li>

          
            
  <li>
    <span class="section">HS16</span>
    <ul>
      
        
  <li>
    <a class="current" title="AD2" href="./">
      AD2
    </a>
    
      
        
      
      
        <ul>
          
            <li class="anchor">
              <a title="Prüfung" href="#prufung">
                Prüfung
              </a>
            </li>
          
            <li class="anchor">
              <a title="Vorlesung 1 - Binary Search Tree" href="#vorlesung-1-binary-search-tree">
                Vorlesung 1 - Binary Search Tree
              </a>
            </li>
          
            <li class="anchor">
              <a title="Vorlesung 2 - AVL-Trees (1)" href="#vorlesung-2-avl-trees-1">
                Vorlesung 2 - AVL-Trees (1)
              </a>
            </li>
          
            <li class="anchor">
              <a title="Vorlesung 4 - Splay-Trees / Merge-Sort" href="#vorlesung-4-splay-trees-merge-sort">
                Vorlesung 4 - Splay-Trees / Merge-Sort
              </a>
            </li>
          
            <li class="anchor">
              <a title="Vorlesung 5 - Quick-Sort" href="#vorlesung-5-quick-sort">
                Vorlesung 5 - Quick-Sort
              </a>
            </li>
          
            <li class="anchor">
              <a title="Vorlesung 6 - Radix-Sort / Pattern Matching" href="#vorlesung-6-radix-sort-pattern-matching">
                Vorlesung 6 - Radix-Sort / Pattern Matching
              </a>
            </li>
          
            <li class="anchor">
              <a title="Vorlesung 8 - Tries" href="#vorlesung-8-tries">
                Vorlesung 8 - Tries
              </a>
            </li>
          
        </ul>
      
    
  </li>

      
        
  <li>
    <span class="section">BuRe1</span>
    <ul>
      
        
  <li>
    <a class="" title="ReIng" href="../reing/">
      ReIng
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="BuPl" href="../bupl/">
      BuPl
    </a>
    
  </li>

      
    </ul>
  </li>

      
        
  <li>
    <a class="" title="C++" href="../cpi/">
      C++
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="EnglHTw" href="../englhtw/">
      EnglHTw
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="MGE" href="../mge/">
      MGE
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="MsTe" href="../mste/">
      MsTe
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="SE1" href="../se1/">
      SE1
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="WED2" href="../wed2/">
      WED2
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <a class="" title="Playground" href="../../playground/">
      Playground
    </a>
    
  </li>

          
        </ul>
        
          <hr>
          <span class="section">The author</span>
          <ul>
            
              
              <li>
                <a href="https://twitter.com/robin_suter" target="_blank" title="@robin_suter on Twitter">
                  @robin_suter on Twitter
                </a>
              </li>
            
            
              
              <li>
                <a href="https://github.com/excape" target="_blank" title="@excape on GitHub">
                  @excape on GitHub
                </a>
              </li>
            
          </ul>
        
      </div>
    </div>
  </div>
</nav>
      </div>
      <article class="article">
        <div class="wrapper">
          
          <h1 id="algorithmen-und-datenstrukturen-2">Algorithmen und Datenstrukturen 2</h1>
<ul>
<li>Visualisierungen: <a href="http://visualgo.net/">http://visualgo.net/</a></li>
</ul>
<h2 id="prufung">Prüfung</h2>
<ul>
<li>Open Book</li>
<li>Vorgaben auf titelblatt</li>
<li>Musterprüfung auf Skripteserver</li>
</ul>
<hr />
<h2 id="vorlesung-1-binary-search-tree">Vorlesung 1 - Binary Search Tree</h2>
<ul>
<li>Ein Heap hat das kleinste oder grösste Element als Root</li>
<li>Eine Suche auf einem Heap würde mit <script type="math/tex">O(n)</script> laufen, da man nicht weiss, welches Child jeweils kleiner / grösser ist</li>
<li>
<p>Multimaps: Pro Key sind mehrere Values erlaubt</p>
</li>
<li>
<p><strong>Folie 5</strong><br />
Voraussetzung: Random Access, Daten müssen sortiert sein</p>
</li>
<li>
<p><strong>Folie 6</strong> </p>
<ul>
<li>Insert: Finden der richtigen Position: <script type="math/tex">O(log(n))</script>, Rest verschieben: <script type="math/tex">O(n)</script>
</li>
<li>Remove gleich wie Insert</li>
</ul>
</li>
<li>
<p><strong>Folie 7</strong>  </p>
<ul>
<li>Der Baum muss so aufgebaut sein, dass der linke Child-Knoten immer &lt;= Parent-Node ist</li>
<li>Externe Knoten speichern keine Daten. Wenn man beim Suchen einen Blattknoten erreicht, ist der Key nicht gefunden</li>
<li>Eine Inorder Traversierung besucht die Keys in aufsteigender Reihenfolge</li>
</ul>
</li>
<li>
<p><strong>Einfügen</strong>  </p>
<ul>
<li>Suchen nach dem einzufügenden Key</li>
<li>Man wird auf einen "Sentinel" external Node treffen</li>
<li>Dort den neuen Key einfügen und in einen internen Knoten umwandeln</li>
<li>Bei einer <em>Multimap</em> kann es mehrere gleiche Keys geben. Dann:<ul>
<li>find, bis man auf den Knoten trifft</li>
<li>nach links weiter suchen bis man auf einen external Node trifft</li>
<li>Dort einfügen und in internen Node umwandeln</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Löschen</strong>  </p>
<ul>
<li>Knoten hat zwei Blatt-Kinder:<ul>
<li>Lösche v und sein linkes Child, rechtes Child rutscht nach oben</li>
</ul>
</li>
<li>Knoten hat ein Blatt-Kind:<ul>
<li>Lösche v und den Blatt-Knoten (links oder rechts), der andere Knoten (mit einem Key) rutscht nach oben</li>
</ul>
</li>
<li>Knoten hat keine Blatt-Kinder:<ul>
<li>Finde den Knoten <code>w</code>, der <code>v</code> in der Inorder-Traversierung folgt ("links unten des rechten Teilbaums von <code>v</code>")</li>
<li>Kopiere den Key von <code>w</code> zu <code>V</code></li>
<li>Lösche <code>w</code> mit dem gleichen Algorithmus wie bei Fall 1 und 2</li>
</ul>
</li>
<li><em>Für die ersten beiden Fälle ist der Algorithmus derselbe</em></li>
</ul>
</li>
<li>
<p><strong>Performance</strong>  </p>
<ul>
<li>Worst Case: Komplett unbalancierter Baum (z.B. Einfügen mit <em>sortiertem</em> Input). Höhe ist <script type="math/tex">O(n)</script>. Dann ist es eine Linked-List</li>
<li>Best Case: Mit der Mitte beginnen, komplett Balanciert.</li>
<li>Höhe <script type="math/tex">log(n)</script>
</li>
<li>Balanciert sich nicht selbst (wie andere Bäume, s. später)</li>
</ul>
</li>
<li><strong>Implementierung</strong><ul>
<li>Hier haben die Attribute der Klasse <code>Knoten</code> die Visibility <code>package</code>, d.h es kann direkt darauf zugegriffen werden</li>
<li>Einfügen: Map (nicht Multimap). Wenn der Key schon vorhanden ist, bleibt er einfach bestehen (key wird zurück gegeben)</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-2-avl-trees-1">Vorlesung 2 - AVL-Trees (1)</h2>
<p>Bei einem AVL Tree muss für jeden Teilbaum gelten, dass die Kinder maximal einen Höhenunterschied von 1 haben.</p>
<p>Beweis: Jeder AVL-Baum mit minimalen Anzahl Knoten <script type="math/tex">n</script> bei Höhe <script type="math/tex">h</script> hat einen linken und rechten Teilbaum. Der eine Teilbaum hat Höhe <script type="math/tex">h - 1</script> und der rechte <script type="math/tex">h - 2</script>
</p>
<p>
<script type="math/tex; mode=display">n(h) = 1 + n(h-1) + n(h-2)</script>
<script type="math/tex; mode=display">n(h) > 2n(h-2)</script>
<script type="math/tex; mode=display">n(h-2) = 1 + n(h-3) + n(h-4)</script>
<script type="math/tex; mode=display">n(h-2) > 2n(h-4)</script>
<script type="math/tex; mode=display">n(h) > 4n(h-4)</script>
<script type="math/tex; mode=display">n(h-4) = 1 + n(h-5) + n(h-6)</script>
<script type="math/tex; mode=display">n(h-4) > 2n(h-6)</script>
<script type="math/tex; mode=display">n(h) > 8n(h-6)</script>
<script type="math/tex; mode=display">\ldots</script>
<script type="math/tex; mode=display">n(h) > 16n(h-8)</script>
<script type="math/tex; mode=display">n(h) > 2^i n(h-2i)</script>
</p>
<p>
<script type="math/tex; mode=display">n_{min}(h=1) = 1</script>
<script type="math/tex; mode=display">n_{min}(h=2) = 2</script>
</p>
<p>
<script type="math/tex; mode=display">i: h-2i = (1 | 2)</script>
<script type="math/tex; mode=display">h = (1 | 2) + 2i</script>
<script type="math/tex; mode=display">\text{bsp.:}</script>
<script type="math/tex; mode=display">i = 1 : h = 3 | 4</script>
<script type="math/tex; mode=display">i = 2 : h = 5 | 6</script>
<script type="math/tex; mode=display">i = 3 : h = 7 | 8</script>
<script type="math/tex; mode=display"> i = \frac h2 - 1 \text{ wobei h/2 gerundet}</script>
Einsetzen in <script type="math/tex">n(h) > 2^i n(h-2i)</script>:
<script type="math/tex; mode=display">n > 2^{\frac h2 - 1} \cdot (1 | 2)</script>
Konstanten heraus streichen:
<script type="math/tex; mode=display">n > 2^{\frac h2-1}</script>
<script type="math/tex; mode=display">log(n) > \frac h2 - 1</script>
<script type="math/tex; mode=display">h < 2\cdot log(n) + 2</script>
<script type="math/tex; mode=display">\rightarrow h \in O(log(n))</script>
</p>
<ul>
<li>Einfügen:<ul>
<li>Den neuen Knoten wie bei einem BST einfügen</li>
<li>Prüfen, ob AVL-Bedingungen verletzt wurden</li>
<li>Aus dem neuen Knoten aus solange nach oben wandern, bis man auf einen Eltern-Knoten eines unbalancierten Teilbaums trifft</li>
</ul>
</li>
<li>Umstrukturierung:<ul>
<li>x, y, z: Aufgrund des Suchpfades Kind, Eltern, Grosseltern</li>
<li>a, b, c: Inorder-Reihenfolge</li>
<li>Wenn es von x bis z nur in eine Richtung geht: Rotation um b (= y)</li>
<li>Bei Richtungsänderung von x bis z:<ul>
<li>Zuerst den Teilbaum b und c (x und y) rotieren, so dass a, b, c wieder in einer Richtung ist wie oben</li>
<li>Wieder wie oben um b rotieren</li>
</ul>
</li>
<li><em>(Tipp:)</em> Jeweils nach Rotation mit Inorder Traversierung prüfen</li>
<li>Eine Restrukturierung mit Cut/Link muss nicht den gleichen Baum ergeben wie mit dem Rotationsverfahren!</li>
</ul>
</li>
<li>Löschen<ul>
<li>Löschen wie bei BST</li>
<li>Die Balance kann verletzt werden</li>
<li>Die Knoten x, y, z sollten im höheren Teilbaum sein (beim Einfügen automatisch gegeben)</li>
<li>Nach dem Restrukturierung kann eine neue Unbalance entstehen! (Im Gegensatz zum Einfügen). Man muss bis zur Root weiter nach Unbalancierten Teilbäumen suchen</li>
</ul>
</li>
<li>Implementierung<ul>
<li>Mit einer AVL-Node wird dessen Höhe gespeichert</li>
<li>actionPos: Die Position, in der etwas passiert ist (z.B. letzte Einfügeposition). Ist ein Attribut der BST-Klasse</li>
<li>Nach dem Einfügen wird die (BST-)Node (Item) mit einer Instanz von AVLItem ersetzt</li>
<li>Besser: Funktion newNode() des BST überschreiben</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-4-splay-trees-merge-sort">Vorlesung 4 - Splay-Trees / Merge-Sort</h2>
<h3 id="splay-trees">Splay-Trees</h3>
<ul>
<li>Nach dem Einfügen ist der eingefügte Knoten immer Root</li>
<li>Beim Suchen wird der Baum auch restrukturiert, der gesuchte Knoten ist danach Root</li>
<li>Knoten mit gleichem Wert können weit auseinander sein</li>
<li>Suchen gleich wie bei BST</li>
<li>Muss nicht Balanced sein wie AVL!</li>
</ul>
<h4 id="splay-operation">Splay-Operation</h4>
<ul>
<li>Wird nach <em>jeder</em> Operation (auch Suchen) ausgeführt</li>
<li>rechts und links Rotation gleich wie bei AV"L</li>
<li>"zig" -&gt; linkes Kind, "zag" -&gt; rechtes Kind</li>
<li>x: betroffener Knoten, y: parent von x, z: parent-parent von x</li>
<li>Rotationen solange wiederholen, bis x Root wird</li>
</ul>
<h4 id="loschen">Löschen</h4>
<ul>
<li>Wie bei BST</li>
<li>Bei "Fall 3": Ersetze Knoten durch inorder-Nachfolger</li>
<li>Splayen mit tiefstem internem <em>zugegriffenem</em> Knoten (Elternknoten des gelöschten)</li>
</ul>
<h4 id="performance">Performance</h4>
<ul>
<li>Splaying: <script type="math/tex">O(h)</script>
<ul>
<li>Durchschnittlich <script type="math/tex">O(logn)</script>
</li>
<li>Worst case ist Höhe h = n, d.h. <script type="math/tex">O(n)</script>
</li>
</ul>
</li>
<li>Oft besuchte Knoten kommen immer näher an die Root, d.h es wird schneller</li>
<li>Anwendung z.B. bei Suchmaschinen</li>
</ul>
<h4 id="splay-entscheid">Splay-Entscheid</h4>
<ul>
<li>Wenn mit find() nicht gefunden wird, der letzte gefunden Knoten nehmen</li>
</ul>
<h3 id="merge-sort">Merge-Sort</h3>
<ul>
<li>Divide and Conquer Prinzip<ul>
<li>Daten in zwei Teilmengen aufteilen</li>
<li>Problem rekursiv für beide Teilmengen lösen</li>
<li>Conquer: Lösungen mischen</li>
<li>Verankerung ist Inputgrösse 1 oder 0</li>
</ul>
</li>
<li>Merge-Sort sortiert Rekursiv die halbe Menge und "merged" die beiden sortierten Teilmengen zusammen</li>
<li>Merge()<ul>
<li>Beide Listen von vorne her leeren</li>
<li>Wenn A kleiner ist, A in S einfügen, sonst B in S einfügen</li>
<li>wenn eine Liste leer, der Rest der anderen an S anfügen</li>
<li>
<script type="math/tex">O(n)</script> mit double-linked-List</li>
</ul>
</li>
<li>Performance<ul>
<li>Die Höhe des Rerkursionsbaums ist <script type="math/tex">O(log n)</script>
</li>
<li>Jede Rekursion braucht <script type="math/tex">O(n)</script>
</li>
<li>Total <script type="math/tex">O(n log n)</script>
</li>
</ul>
</li>
<li>Java.util.sort ist ein modifizierter Merge-Sort<ul>
<li>Wenn das grösste Element der ersten Liste kleiner als das kleinste Element der zweiten Liste ist, kann man einfach die beiden Listen aneinander hängen (keine Vergleiche nötig)</li>
<li>Garantiert <script type="math/tex">O(n log n)</script>
</li>
</ul>
</li>
</ul>
<p><img alt="Vergleich Sortieralgorithmen" src="../img/sort_vergleiche.png" /></p>
<ul>
<li>Implementierung nicht-rekursiv<ul>
<li>mit i = 1: Zweier-Pärchen sortieren und in out schreiben</li>
<li>in und out swappen</li>
<li>Nun Vierer-Gruppen (zwei Pärchen) sortiert in out schreiben</li>
<li>in und out swappen</li>
<li>usw... Es wird immer verdoppelt</li>
<li>Quasi im rekurvis-Baum "Bottom up"</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-5-quick-sort">Vorlesung 5 - Quick-Sort</h2>
<ul>
<li>Vergleich Insertion-Sort (<script type="math/tex">O(n^2)</script>) und Merge-Sort (<script type="math/tex">O(n log n)): Bei \(2^{14}</script> Elementen ist Merge-Sort 100x schneller, bei 1 Mio. Elementen ist es 6'400x schneller</li>
<li>Insertion Sort würde für 1 Mio. Elemente ca. 1h 47' benötigen, merge-Sort nur einige Sekunden</li>
</ul>
<h3 id="quick-sort">Quick-Sort</h3>
<ul>
<li>Partitionierung in 3 Mengen: Less, Equal und Greater mit einem Pivot x<ul>
<li>Jedes Element in die richtige Menge kopieren -&gt; <script type="math/tex">O(n)</script>
</li>
</ul>
</li>
<li>Rekursiver Aufruf mit L und G</li>
<li>Zusammensetzen: L, E, G hintereinander wieder einfügen</li>
</ul>
<p><img alt="Vergleich Sortieralgorithmen" src="../img/quicksort_tree.png" /></p>
<ul>
<li>Wenn der Pivot immer das minimum oder maximum ist, gibt es einen einseitigen "tree", d.h Worst-Case ist <script type="math/tex">O(n^2)</script>
</li>
<li>Der optimale Pivot wäre der mittlere Wert</li>
<li>Wenn die Daten normalverteilt sind, gibt es zu 50% "bad-calls" bei zufälliger Wahl des Pivots (1. und 4. Viertel)</li>
<li>Erwartet wird ein Baum mit Höhe <script type="math/tex">log n</script>. Jedes Level benötigt <script type="math/tex">O(n)</script>, also total <script type="math/tex">O(n log n)</script>
</li>
<li>In-Place Quicksort<ul>
<li>Worst-Case: Wenn die Liste bereits sortiert ist</li>
</ul>
</li>
</ul>
<h3 id="sorting-lower-bound">Sorting Lower Bound</h3>
<ul>
<li>Jede Permutation von Daten zeigt einen Pfad durch den Entscheidungsbaum</li>
<li>Das gibt n! Permutationen, also ist die Höhe des Baumes log(n!)
<script type="math/tex; mode=display">n^n > n! > {\frac n2}^{\frac n2}</script>
</li>
<li>Die Untere Grenze für <em>Vergleichs</em>algorithmen ist <script type="math/tex">O(n log(n))</script>
</li>
</ul>
<h3 id="bucket-sort">Bucket-Sort</h3>
<ul>
<li>Eine Sequenz mit Key-Value-Paaren</li>
<li>Jedes Item in ein Array mit dem Key als Index kopieren<ul>
<li>Genauer ein Array von Listen, Elemente mit gleichem Key werden der Liste angehängt</li>
</ul>
</li>
<li>Array durch iterieren und der Reihe nach ausgeben</li>
<li>Laufzeit: <script type="math/tex">O(n + N)</script>, wobei N der grösstmögliche Wert der Keys ist<ul>
<li>Kein Widerspruch zu oben, weil Algorithmus nicht vergleichs-basiert ist</li>
</ul>
</li>
<li>Eingeschränkt auf ganze, positive Zahlen</li>
<li><em>Stabile</em> Sort-Eigenschaft: die relative Ordnung von Items mit gleichem Wert wird nicht verändert</li>
</ul>
<hr />
<h2 id="vorlesung-6-radix-sort-pattern-matching">Vorlesung 6 - Radix-Sort / Pattern Matching</h2>
<h3 id="lexikographische-sortierung">Lexikographische Sortierung</h3>
<ul>
<li>Die letzte Dimension wird <em>zuletzt</em> sortiert, d.h die Dimension mit 1. Priorität am Schluss</li>
<li>Einfachste Anwendung ist mit Strings</li>
<li>Radix-Sort<ul>
<li>Lexikographische Sortierung mit Bucket-Sort</li>
</ul>
</li>
</ul>
<h3 id="pattern-matching">Pattern Matching</h3>
<ul>
<li>Ziel: In einer Sequenz von Zeichen ein Pattern finden</li>
<li>Substring wird hier inklusive end-index angegeben. In Java geht der Substring bis endIndex - 1!</li>
<li>Brute-Force-Methode<ul>
<li>Pattern am Anfang des Textes ansetzen und Zeichen für Zeichen durchlaufen bis zum Ende</li>
<li>Bei jeder Iteration prüfen, ob das Pattern übereinstimmt</li>
<li>Performance: Pattern m n Mal durchsuchen -&gt; <script type="math/tex">O(n\cdot m)</script>
</li>
</ul>
</li>
<li>Boyer-Moore Heuristik<ul>
<li>"Looking Glass": Starte jeweils am Ende des Patterns</li>
<li>"Character Jump": Bei einem Mismatch wird mit dem Pattern an die nächstmögliche Position gesprungen, wo das Zeichen im Text im Pattern vorkommt (wenn nicht, kann es gleich weiter geschoben werden um ganze Patternlänge)<ul>
<li>Es muss zwinged auf das letzt auftretende (möglichst weit rechte) Zeichen ausgerichtet werden</li>
<li>Wenn man dabei nach links schieben würde, wird stattdessen um 1 nach rechts geschoben</li>
</ul>
</li>
<li>Die Last Occurence Funktion speichert von jedem zeichen im Alphabet die letzte Position im Pattern (wenn es nicht vorkommt, -1)</li>
<li>Damit kann mit \O(1)) die Anzahl der Verschiebungen berechnet werden</li>
<li>Performance: Im Worst Case <script type="math/tex">O(n\cdot m + s)</script>, also schlechter als Brute Force. Im Durchschnitt ist er aber sehr schnell für Textanalysen</li>
</ul>
</li>
<li>KMP Algorithmus<ul>
<li>Sucht Suffixe, die auch Präfixe vom Pattern sind</li>
<li>So werden nach dem Verschieben nach rechts redundante Vergleiche vermieden</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-8-tries">Vorlesung 8 - Tries</h2>
<ul>
<li>Ziel: Preprocessing vom Text (n), um Suchen in Abhängigkeit von m zu erreichen (statt voher von n)</li>
<li>Ein "Trie" ist ein geordneter Baum, wobei jeder Knoten ausser der Root ein Zeichen hat</li>
<li>Die Strings entstehen vom ersten Child-Knoten bis zu den externen Nodes</li>
<li>Folie 7<ul>
<li>Erster Index ist Index in Wörter-Array S</li>
<li>Zweiter und dritter Index ist Range in diesem String</li>
</ul>
</li>
<li>Mit einem normalen Trie findet man nur komplette Wörter und Präfixe als Matches, keine Suffixe</li>
<li>Dafür für jedes Wort einen Suffix-Trie erstellen<ul>
<li>Jeder mögliche Suffix wird in den Trie eingefügt</li>
<li>Auch substrings werden darin gefunden, da sie präfixe der Suffixe im Suffix-Trie sind</li>
</ul>
</li>
</ul>
<hr />
<h1 id="vorlesung-9-dynamische-programmierung">Vorlesung 9 - Dynamische Programmierung</h1>
<ul>
<li>Rucksack-Problem ist hier nur polynomiell lösbar, weil es ganze Zahlen sind (sonst ist es NP-Vollständig)</li>
<li>Ziel ist immer, Resultate von Subproblemen zu speichern, weil sie Einfluss auf die anderen Lösungen (der Subprobleme) haben</li>
<li>Beispiel Fibonacci: Mit normaler Rekursiver Variante werden die tieferen Fib-Zahlen immer mehrmals berechnen. Viel schneller ist es, die Zwischenergebnisse jeweils in einer Tabelle zu speichern, und nur berechnen, wenn sie noch nicht darin vorkommen.</li>
<li>Beispiel LCS<ul>
<li>Horizontal ist X(m), Vertikal Y(n)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>C</th>
<th>G</th>
<th>A</th>
<th>T</th>
<th>...</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>...</td>
</tr>
<tr>
<td>T</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>...</td>
</tr>
<tr>
<td>T</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="vorlesung-10-graphen-1">Vorlesung 10 - Graphen (1)</h2>
<ul>
<li>Definition: <code>V</code> ist Set von Vertices, <code>E</code> eine Collection von Vertices-Paaren (=Kanten)<ul>
<li>Kanten und Vertizes speichern Elemente</li>
<li>gerichtet: Kante hat eine Richtung</li>
<li>Gibt auch Graphen, die gerichtete und ungerichtete Kanten mischen (z.B. bei Klassendiagramm)</li>
<li><em>inzident</em>: Kante endet an einem Knoten V</li>
<li>parallele kanten: k(anten, die die gleichen zwei Knoten verbinden</li>
<li>Schleife: Kante von Knoten auf sich selbst</li>
<li>Einfacher Pfad: Jede Kante und Vertices kommt nur einmal vor</li>
<li>Zyklus endet ändert immer in einer Kante (die letzte Verbindung zum Startknoten)</li>
<li>Die Summe der Grade in einem Graph ist immer 2*m (2 * Anzahl Kanten)</li>
<li>Voll vermaschter Graph hat <script type="math/tex">\frac{n(n-1)}2</script> Kanten, das ist die maximal mögliche Anzahl<ul>
<li>Das ist <script type="math/tex">\frac{n(n+1)}2 - n</script>
</li>
</ul>
</li>
</ul>
</li>
<li>In Kanten-Listen-Struktur hat jeweils der Vertex und die Kante eine Referenze auf die Position in der Sequenz. Dies ermöglicht, beim Löschen ein Vertex / eine Kante mit <script type="math/tex">O(1)</script> aus der Liste zu löschen<ul>
<li><code>areAdjacent()</code>, <code>removeVertex()</code> und <code>incidentEdges()</code> brauchen <script type="math/tex">O(m)</script>
</li>
<li>Restliche Operationen <script type="math/tex">O(1)</script>
</li>
</ul>
</li>
<li>Adjazent-Listen Struktur<ul>
<li>Jeder Vertex hat eine Referenz auf eine Liste, die Referenzen auf alle incident Vertices enthält</li>
<li>Die Kanten halten eine Referenz auf eine Position in der Incident-Liste</li>
<li>Beim Löschen eines Vertex müssen die Kanten <em>und</em> die Referenzen in den Incident-Listen gelöscht werden</li>
<li>Laufzeit von <code>removeVertex(v)</code> ist abhängig von der Länge der Incident-Liste, also <script type="math/tex">O(deg(v))</script>
</li>
</ul>
</li>
<li>Adjazenz-Matrix Struktur<ul>
<li>Einfügen ist langsam, da die Matrix vergrössert (=kopiert) werden muss</li>
<li><code>areAdjacent()</code> ist schnell (<script type="math/tex">O(1)</script>), da man direkt die Position in der Matrix abfragen kann</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-11-graphen-2">Vorlesung 11 - Graphen (2)</h2>
<ul>
<li>spanning Subtree: Ein Subgraph, der alle Vertizes des Graphen enthält</li>
<li>Verbundene Komponente: Ein verbundener Subgraph</li>
<li>Tree: Verbundener Graph ohne Zyklen</li>
<li>Forest: Mehrere Trees als Komponente, ohne Zyklen</li>
<li>Spanning Tree: Spanning Subtree, der keine Zyklen enthält</li>
</ul>
<h3 id="depth-first-search">Depth-First Search</h3>
<ul>
<li>Technik zur Traversierung von Graphen</li>
<li>Bestimmt, ob Graph verbunden ist und verbundene Komponenten</li>
<li>Berechnet spanning Forest</li>
<li>Algorithmus: Die Kanten werden mit "Discovery" oder "Back" markiert<ul>
<li>Alle "Discovery"-Kanten beschreiben am Ende einen Spanning Tree</li>
</ul>
</li>
<li>Wenn der äusserste Loop in <code>DFS(g)</code> mehr als einmal ein "unexplored" vertex findet, ist der Graph nicht verbunden</li>
</ul>
<h3 id="breath-first-search">Breath-First Search</h3>
<ul>
<li>Sehr ähnlich zu DFS</li>
<li>Sucht zuerst in die Breite statt in die Tiefe</li>
<li>Besser als DFS, um kurze Pfade zu finden</li>
<li>Jeder Node in der Liste <em>i</em> hat Distanz 1 zu Liste <em>i-1</em></li>
<li>Performance ist gleich wie bei DFS <script type="math/tex">O(n+m)</script>, wenn Adjazenzliste genutzt wird</li>
<li>Findet Pfad mit minimaler Anzahl Knoten</li>
<li>Biconnected Komponenten<ul>
<li>Cut-Vertex ist Vertex, der zwei grössere Teilgraphen verbindet (z.B. Single Point of Failure in einem Netzwerk)</li>
<li>Biconnectd Komponenten sind Teilgraphen, die an zwei Vertices verbunden sind (statt nur an einem <em>Cut</em>-Vertex)</li>
</ul>
</li>
</ul>
<hr />
<h3 id="vorlesung-12-gerichtete-graphen">Vorlesung 12 - Gerichtete Graphen</h3>
<ul>
<li><em>Alle</em> Kanten in einem Graph sind gewichtet</li>
<li>Max. Kanten bei einem einfachen Graphen ist <script type="math/tex">n(n-1)</script>, doppelt so viele wie beim ungerichteten Graphen (beide Richtungen)</li>
<li>DFS gibt einen Baum von erreichbaren Vertices vom Startwert mit gerichteten Graphen. Dies ist abhängig vom Start-Vertex! Es müssen nicht alle erreicht werden, auch wenn der ganze Graph verbunden ist</li>
<li><em>Strong Connectivity</em>: Jeder Vertex ist von jedem anderen erreichbar<ul>
<li>Algorithmus zum Prüfen:<ul>
<li>DFS für irgendeinen Vertex ausführen und prüfen, ob alle Vertices besucht werden. Falls nicht -&gt; <em>False</em></li>
<li>Graph <em>G'</em> mit umgekehrten Kanten erstellen und die Suche wiederholen. Falls nicht alle besucht -&gt; <em>False</em></li>
</ul>
</li>
</ul>
</li>
<li><em>Streng verbundene Komponente</em>: Subgraph, der streng verbunden ist</li>
<li>Transitiver Abschluss: Ein Digraph G* des Graphen G, wobei für alle Pfade von u nach v eine gerichtete Kante u zu v eingetragen wird<ul>
<li>Mit DFS: Startkante mitgeben und bei jeder <em>Discovery</em>-Edge eine Kante vom Startwert zum disovered Vertex einfügen. Laufzeit ist aber <script type="math/tex">O(n(n+m))</script>
</li>
</ul>
</li>
<li>Ansatz mit Floyd-Warshall:<ul>
<li>Vertices nummerieren und immer nur 1 bis k anschauen</li>
<li>Laufzeit <script type="math/tex">O(n^3)</script>
<ul>
<li>Schneller als Tiefensuche! Denn <em>m</em> ist <script type="math/tex">O(n^2)</script>, damit ist der ganze Algorithmus auch <script type="math/tex">O(n^3)</script>
</li>
</ul>
</li>
<li>Grundsatz: Wenn a mit b verbunden und b mit c verbunden, ist auch a mit c verbunden</li>
</ul>
</li>
<li><em>DAG</em> - Directed Acyclic Graph: Ein gerichteter Graph ohne (gerichtete) Zyklen</li>
<li>Topologische Ordnung: Reihenfolge der Vertices, so dass jeder Index kleiner ist als dieser seiner Outgoing Edges<ul>
<li>Ist nicht eindeutig, gibt beliebig viele Lösungen</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-13-dijkstra">Vorlesung 13 - Dijkstra</h2>
<ul>
<li>Jede Node in der Wolke hat die kürzeste Distanz zu s gespeichert</li>
<li>Wolke: Beginnt bei Startvertex s, wird immer grösser</li>
<li>distanz auf jedem Vertex wird initialisiert mit <script type="math/tex">+\infty</script>
</li>
<li>Während dem Algorithmus wird alles innerhalb der Wolke nicht mehr verändert</li>
<li>Adaptierbare PQ, weil Key verändert werden kann</li>
<li><em>Locator</em>: eine Referenz auf die Entry in der PQ</li>
<li>Algorithmus<ul>
<li>Distanz von Startvertex auf 0 setzen, alle anderen auf <script type="math/tex">\infty</script>
</li>
<li>Alle Vertices mit initialisierten Distanzen in PQ einfügen, Locator darin mit dem Vertex speichern</li>
<li>Durch Vertices iterieren (bis Queue empty)<ul>
<li>Erstes RemoveMin() gibt Startvertex zurück (weil Distanz 0)</li>
<li>Durch Incident Edges iterieren<ul>
<li>r = relaxation distance</li>
<li>Wenn r ("neue" Distanz) kleiner als aktuelle, bekommt der opposite vertex die neue, verbesserte Distanz</li>
<li>Distanz in der PQ updaten</li>
</ul>
</li>
<li>Weiter mit Vertex mit kleinster Distanz, dies wird im ersten Schritt ein neu hinzugefügter Vertex sein</li>
</ul>
</li>
</ul>
</li>
<li>Funktioniert nur mit positiven Gewichten!</li>
<li>Komplexität: <script type="math/tex">O((n+m)\cdot log(n))</script>
</li>
</ul>
<hr />
<h2 id="vorlesung-14-more-spanning-tree-algorithms">Vorlesung 14 - More Spanning Tree Algorithms</h2>
<ul>
<li>Bellman-Ford<ul>
<li>Geht auch mit negativen Gewichten</li>
<li>Es werden n (anzahl Vertices) mal alle Edges des Graphen durchlaufen (nicht incident edges!)</li>
<li>Bei kleinem Beispiel ist der Algorithmus schon nach 2 äusseren loops fertig</li>
<li>Es gibt hier keine "Wolke" wie bei Dijkstra, Nodes "ausserhalb" können "innere" Nodes verändern</li>
</ul>
</li>
<li>DAG-Algorithmus<ul>
<li>Geht auch mit negativen Gewichten</li>
<li>DAG: Gerichteter Graph ohne Zyklen</li>
<li>Iteriert mit der topologischen Reihenfolge des Graphen</li>
</ul>
</li>
</ul>
<h3 id="minimum-spanning-tree">Minimum Spanning Tree</h3>
<ul>
<li>Ein aufspannender Baum eines gewichteten Graphen mit minimalem totalen Gewicht</li>
<li>Schlaufe: Wenn durch hinzufügen einer Schlaufe die Kante e kleiner als irgendeine andere Kante in der Schlaufe ist, wird diese im Baum getauscht -&gt; Es ist ein besserer spanning Tree</li>
<li>Aufteilung: Wenn der Graph in zwei Teilmengen aufgeteilt wird, ist die Kante mit kleinstem Gewicht, die die beiden Teilmengen verbinden, sicher teil des minimalen Spannig Tree</li>
</ul>
<h4 id="kruskals-algorithmus">Kruskal's Algorithmus</h4>
<ul>
<li>Initialisieren mit Cloud(v) für jeden Vertex v, worin nur v selbst ist</li>
<li>Priority Queue mit Gewicht -&gt; Edge mit kleinstem Gewicht wird zuerst verarbeitet</li>
<li>Jeweild Edges in T hinzufügen und Cloud mergen, ausser die Vertices sind bereits in derselben Cloud</li>
<li>Wenn T n-1 Kanten hat, ist es ein aufspannender freier Baum (alle Vertices verbunden) -&gt; Abbruchbedingung</li>
<li>Datenstruktur<ul>
<li>Braucht <code>find(u)</code>, um Wolke von u zurück zu geben</li>
<li>Set als Liste von Vertices, die jeweils eine Back-Referenz auf die Liste haben</li>
<li>Mit <code>union(u,v)</code> werden Sets gemerged (alle Elemente des einen in die andere kopieren)</li>
</ul>
</li>
</ul>
<h4 id="prim-jarnik-algorithmus">Prim-Jarnik Algorithmus</h4>
<ul>
<li>Fast wie Dijkstra</li>
<li>Unterschied: <code>r = weight(e)</code> statt <code>r = weight(e) + distance</code></li>
</ul>
<p><img alt="" src="../img/spt_vs_mst.jpg" /></p>
          <aside class="copyright" role="note">
            
              Copyright (c) 2016 Robin Suter &ndash;
            
            Documentation built with
            <a href="http://www.mkdocs.org" target="_blank">MkDocs</a>
            using the
            <a href="http://squidfunk.github.io/mkdocs-material/" target="_blank">
              Material
            </a>
            theme.
          </aside>
          
            <footer class="footer">
              
  <nav class="pagination" aria-label="Footer">
    <div class="previous">
      
        <a href="../.." title="Home">
          <span class="direction">
            Previous
          </span>
          <div class="page">
            <div class="button button-previous" role="button" aria-label="Previous">
              <i class="icon icon-back"></i>
            </div>
            <div class="stretch">
              <div class="title">
                Home
              </div>
            </div>
          </div>
        </a>
      
    </div>
    <div class="next">
      
        <a href="../reing/" title="ReIng">
          <span class="direction">
            Next
          </span>
          <div class="page">
            <div class="stretch">
              <div class="title">
                ReIng
              </div>
            </div>
            <div class="button button-next" role="button" aria-label="Next">
              <i class="icon icon-forward"></i>
            </div>
          </div>
        </a>
      
    </div>
  </nav>

            </footer>
          
        </div>
      </article>
      <div class="results" role="status" aria-live="polite">
        <div class="scrollable">
          <div class="wrapper">
            <div class="meta"></div>
            <div class="list"></div>
          </div>
        </div>
      </div>
    </main>
    <script>
      var base_url = '../..';
      var repo_id  = '';
    </script>
    <script src="../../assets/javascripts/application-997097ee0c.js"></script>
    
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
    
    
  </body>
</html>