<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Robin Suter">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>AD2 - HSR Notizen</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  <link href="../../extra.css" rel="stylesheet">
  
  <script>
    // Current page data
    var mkdocs_page_name = "AD2";
    var mkdocs_page_input_path = "hs16/ad2.md";
    var mkdocs_page_url = "/hs16/ad2/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> HSR Notizen</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">Home</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>HS16</span></li>

        
            
    <li class="toctree-l1 current">
        <a class="current" href="./">AD2</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#algorithmen-und-datenstrukturen-2">Algorithmen und Datenstrukturen 2</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-1-binary-search-tree">Vorlesung 1 - Binary Search Tree</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-2-avl-trees-1">Vorlesung 2 - AVL-Trees (1)</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-4-splay-trees-merge-sort">Vorlesung 4 - Splay-Trees / Merge-Sort</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-5-quick-sort">Vorlesung 5 - Quick-Sort</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-6-radix-sort-pattern-matching">Vorlesung 6 - Radix-Sort / Pattern Matching</a></li>
                
            
            </ul>
        
    </li>

        
            
    <ul class="subnav">
    <li><span>BuRe1</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../reing/">ReIng</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../bupl/">BuPl</a>
        
    </li>

        
    </ul>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../cpi/">C++</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../englhtw/">EnglHTw</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../mge/">MGE</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../mste/">MsTe</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../se1/">SE1</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../wed2/">WED2</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../playground/">Playground</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">HSR Notizen</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>HS16 &raquo;</li>
        
      
    
    <li>AD2</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/Excape/hsr-docs-hs16/edit/master/docs/hs16/ad2.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="algorithmen-und-datenstrukturen-2">Algorithmen und Datenstrukturen 2</h1>
<ul>
<li>Visualisierungen: <a href="http://visualgo.net/">http://visualgo.net/</a></li>
</ul>
<h2 id="vorlesung-1-binary-search-tree">Vorlesung 1 - Binary Search Tree</h2>
<ul>
<li>Ein Heap hat das kleinste oder grösste Element als Root</li>
<li>Eine Suche auf einem Heap würde mit <script type="math/tex">O(n)</script> laufen, da man nicht weiss, welches Child jeweils kleiner / grösser ist</li>
<li>
<p>Multimaps: Pro Key sind mehrere Values erlaubt</p>
</li>
<li>
<p><strong>Folie 5</strong><br />
Voraussetzung: Random Access, Daten müssen sortiert sein</p>
</li>
<li>
<p><strong>Folie 6</strong> </p>
<ul>
<li>Insert: Finden der richtigen Position: <script type="math/tex">O(log(n))</script>, Rest verschieben: <script type="math/tex">O(n)</script>
</li>
<li>Remove gleich wie Insert</li>
</ul>
</li>
<li>
<p><strong>Folie 7</strong>  </p>
<ul>
<li>Der Baum muss so aufgebaut sein, dass der linke Child-Knoten immer &lt;= Parent-Node ist</li>
<li>Externe Knoten speichern keine Daten. Wenn man beim Suchen einen Blattknoten erreicht, ist der Key nicht gefunden</li>
<li>Eine Inorder Traversierung besucht die Keys in aufsteigender Reihenfolge</li>
</ul>
</li>
<li>
<p><strong>Einfügen</strong>  </p>
<ul>
<li>Suchen nach dem einzufügenden Key</li>
<li>Man wird auf einen "Sentinel" external Node treffen</li>
<li>Dort den neuen Key einfügen und in einen internen Knoten umwandeln</li>
<li>Bei einer <em>Multimap</em> kann es mehrere gleiche Keys geben. Dann:<ul>
<li>find, bis man auf den Knoten trifft</li>
<li>nach links weiter suchen bis man auf einen external Node trifft</li>
<li>Dort einfügen und in internen Node umwandeln</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Löschen</strong>  </p>
<ul>
<li>Knoten hat zwei Blatt-Kinder:<ul>
<li>Lösche v und sein linkes Child, rechtes Child rutscht nach oben</li>
</ul>
</li>
<li>Knoten hat ein Blatt-Kind:<ul>
<li>Lösche v und den Blatt-Knoten (links oder rechts), der andere Knoten (mit einem Key) rutscht nach oben</li>
</ul>
</li>
<li>Knoten hat keine Blatt-Kinder:<ul>
<li>Finde den Knoten <code>w</code>, der <code>v</code> in der Inorder-Traversierung folgt ("links unten des rechten Teilbaums von <code>v</code>")</li>
<li>Kopiere den Key von <code>w</code> zu <code>V</code></li>
<li>Lösche <code>w</code> mit dem gleichen Algorithmus wie bei Fall 1 und 2</li>
</ul>
</li>
<li><em>Für die ersten beiden Fälle ist der Algorithmus derselbe</em></li>
</ul>
</li>
<li>
<p><strong>Performance</strong>  </p>
<ul>
<li>Worst Case: Komplett unbalancierter Baum (z.B. Einfügen mit <em>sortiertem</em> Input). Höhe ist <script type="math/tex">O(n)</script>. Dann ist es eine Linked-List</li>
<li>Best Case: Mit der Mitte beginnen, komplett Balanciert.</li>
<li>Höhe <script type="math/tex">log(n)</script>
</li>
<li>Balanciert sich nicht selbst (wie andere Bäume, s. später)</li>
</ul>
</li>
<li><strong>Implementierung</strong><ul>
<li>Hier haben die Attribute der Klasse <code>Knoten</code> die Visibility <code>package</code>, d.h es kann direkt darauf zugegriffen werden</li>
<li>Einfügen: Map (nicht Multimap). Wenn der Key schon vorhanden ist, bleibt er einfach bestehen (key wird zurück gegeben)</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-2-avl-trees-1">Vorlesung 2 - AVL-Trees (1)</h2>
<p>Bei einem AVL Tree muss für jeden Teilbaum gelten, dass die Kinder maximal einen Höhenunterschied von 1 haben.</p>
<p>Beweis: Jeder AVL-Baum mit minimalen Anzahl Knoten <script type="math/tex">n</script> bei Höhe <script type="math/tex">h</script> hat einen linken und rechten Teilbaum. Der eine Teilbaum hat Höhe <script type="math/tex">h - 1 </script> und der rechte <script type="math/tex">h - 2</script>
</p>
<p>
<script type="math/tex; mode=display">n(h) = 1 + n(h-1) + n(h-2)</script>
<script type="math/tex; mode=display">n(h) > 2n(h-2)</script>
<script type="math/tex; mode=display">n(h-2) = 1 + n(h-3) + n(h-4)</script>
<script type="math/tex; mode=display">n(h-2) > 2n(h-4)</script>
<script type="math/tex; mode=display">n(h) > 4n(h-4)</script>
<script type="math/tex; mode=display">n(h-4) = 1 + n(h-5) + n(h-6)</script>
<script type="math/tex; mode=display">n(h-4) > 2n(h-6)</script>
<script type="math/tex; mode=display">n(h) > 8n(h-6)</script>
<script type="math/tex; mode=display">\ldots</script>
<script type="math/tex; mode=display">n(h) > 16n(h-8)</script>
<script type="math/tex; mode=display">n(h) > 2^i n(h-2i)</script>
</p>
<p>
<script type="math/tex; mode=display">n_{min}(h=1) = 1</script>
<script type="math/tex; mode=display">n_{min}(h=2) = 2</script>
</p>
<p>
<script type="math/tex; mode=display">i: h-2i = (1 | 2)</script>
<script type="math/tex; mode=display">h = (1 | 2) + 2i</script>
<script type="math/tex; mode=display">\text{bsp.:}</script>
<script type="math/tex; mode=display">i = 1 : h = 3 | 4</script>
<script type="math/tex; mode=display">i = 2 : h = 5 | 6</script>
<script type="math/tex; mode=display">i = 3 : h = 7 | 8</script>
<script type="math/tex; mode=display"> i = \frac h2 - 1 \text{ wobei h/2 gerundet}</script>
Einsetzen in <script type="math/tex">n(h) > 2^i n(h-2i)</script>:
<script type="math/tex; mode=display">n > 2^{\frac h2 - 1} \cdot (1 | 2)</script>
Konstanten heraus streichen:
<script type="math/tex; mode=display">n > 2^{\frac h2-1}</script>
<script type="math/tex; mode=display">log(n) > \frac h2 - 1</script>
<script type="math/tex; mode=display">h < 2\cdot log(n) + 2</script>
<script type="math/tex; mode=display">\rightarrow h \in O(log(n))</script>
</p>
<ul>
<li>Einfügen:<ul>
<li>Den neuen Knoten wie bei einem BST einfügen</li>
<li>Prüfen, ob AVL-Bedingungen verletzt wurden</li>
<li>Aus dem neuen Knoten aus solange nach oben wandern, bis man auf einen Eltern-Knoten eines unbalancierten Teilbaums trifft</li>
</ul>
</li>
<li>Umstrukturierung:<ul>
<li>x, y, z: Aufgrund des Suchpfades Kind, Eltern, Grosseltern</li>
<li>a, b, c: Inorder-Reihenfolge</li>
<li>Wenn es von x bis z nur in eine Richtung geht: Rotation um b (= y)</li>
<li>Bei Richtungsänderung von x bis z:<ul>
<li>Zuerst den Teilbaum b und c (x und y) rotieren, so dass a, b, c wieder in einer Richtung ist wie oben</li>
<li>Wieder wie oben um b rotieren</li>
</ul>
</li>
<li><em>(Tipp:)</em> Jeweils nach Rotation mit Inorder Traversierung prüfen</li>
<li>Eine Restrukturierung mit Cut/Link muss nicht den gleichen Baum ergeben wie mit dem Rotationsverfahren!</li>
</ul>
</li>
<li>Löschen<ul>
<li>Löschen wie bei BST</li>
<li>Die Balance kann verletzt werden</li>
<li>Die Knoten x, y, z sollten im höheren Teilbaum sein (beim Einfügen automatisch gegeben)</li>
<li>Nach dem Restrukturierung kann eine neue Unbalance entstehen! (Im Gegensatz zum Einfügen). Man muss bis zur Root weiter nach Unbalancierten Teilbäumen suchen</li>
</ul>
</li>
<li>Implementierung<ul>
<li>Mit einer AVL-Node wird dessen Höhe gespeichert</li>
<li><code>actionPos</code>: Die Position, in der etwas passiert ist (z.B. letzte Einfügeposition). Ist ein Attribut der BST-Klasse</li>
<li>Nach dem Einfügen wird die (BST-)Node (<code>Item</code>) mit einer Instanz von <code>AVLItem</code> ersetzt</li>
<li>Besser: Funktion <code>newNode()</code> des BST überschreiben</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-4-splay-trees-merge-sort">Vorlesung 4 - Splay-Trees / Merge-Sort</h2>
<h3 id="splay-trees">Splay-Trees</h3>
<ul>
<li>Nach dem Einfügen ist der eingefügte Knoten immer Root</li>
<li>Beim Suchen wird der Baum auch restrukturiert, der gesuchte Knoten ist danach Root</li>
<li>Knoten mit gleichem Wert können weit auseinander sein</li>
<li>Suchen gleich wie bei BST</li>
<li>Muss nicht Balanced sein wie AVL!</li>
</ul>
<h4 id="splay-operation">Splay-Operation</h4>
<ul>
<li>Wird nach <em>jeder</em> Operation (auch Suchen) ausgeführt</li>
<li>rechts und links Rotation gleich wie bei AV"L</li>
<li>"zig" -&gt; linkes Kind, "zag" -&gt; rechtes Kind</li>
<li>x: betroffener Knoten, y: parent von x, z: parent-parent von x</li>
<li>Rotationen solange wiederholen, bis x Root wird</li>
</ul>
<h4 id="loschen">Löschen</h4>
<ul>
<li>Wie bei BST</li>
<li>Bei "Fall 3": Ersetze Knoten durch inorder-Nachfolger</li>
<li>Splayen mit tiefstem internem <em>zugegriffenem</em> Knoten (Elternknoten des gelöschten)</li>
</ul>
<h4 id="performance">Performance</h4>
<ul>
<li>Splaying: <script type="math/tex">O(h)</script>
<ul>
<li>Durchschnittlich <script type="math/tex">O(logn)</script>
</li>
<li>Worst case ist Höhe h = n, d.h. <script type="math/tex">O(n)</script>
</li>
</ul>
</li>
<li>Oft besuchte Knoten kommen immer näher an die Root, d.h es wird schneller</li>
<li>Anwendung z.B. bei Suchmaschinen</li>
</ul>
<h4 id="splay-entscheid">Splay-Entscheid</h4>
<ul>
<li>Wenn mit find() nicht gefunden wird, der letzte gefunden Knoten nehmen</li>
</ul>
<h3 id="merge-sort">Merge-Sort</h3>
<ul>
<li>Divide and Conquer Prinzip<ul>
<li>Daten in zwei Teilmengen aufteilen</li>
<li>Problem rekursiv für beide Teilmengen lösen</li>
<li>Conquer: Lösungen mischen</li>
<li>Verankerung ist Inputgrösse 1 oder 0</li>
</ul>
</li>
<li>Merge-Sort sortiert Rekursiv die halbe Menge und "merged" die beiden sortierten Teilmengen zusammen</li>
<li>Merge()<ul>
<li>Beide Listen von vorne her leeren</li>
<li>Wenn A kleiner ist, A in S einfügen, sonst B in S einfügen</li>
<li>wenn eine Liste leer, der Rest der anderen an S anfügen</li>
<li>
<script type="math/tex">O(n)</script> mit double-linked-List</li>
</ul>
</li>
<li>Performance<ul>
<li>Die Höhe des Rerkursionsbaums ist <script type="math/tex">O(log n)</script>
</li>
<li>Jede Rekursion braucht <script type="math/tex">O(n)</script>
</li>
<li>Total <script type="math/tex">O(n log n)</script>
</li>
</ul>
</li>
<li>Java.util.sort ist ein modifizierter Merge-Sort<ul>
<li>Wenn das grösste Element der ersten Liste kleiner als das kleinste Element der zweiten Liste ist, kann man einfach die beiden Listen aneinander hängen (keine Vergleiche nötig)</li>
<li>Garantiert <script type="math/tex">O(n log n)</script>
</li>
</ul>
</li>
</ul>
<p><img alt="Vergleich Sortieralgorithmen" src="../img/sort_vergleiche.png" /></p>
<ul>
<li>Implementierung nicht-rekursiv<ul>
<li>mit i = 1: Zweier-Pärchen sortieren und in out schreiben</li>
<li>in und out swappen</li>
<li>Nun Vierer-Gruppen (zwei Pärchen) sortiert in out schreiben</li>
<li>in und out swappen</li>
<li>usw... Es wird immer verdoppelt</li>
<li>Quasi im rekurvis-Baum "Bottom up"</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-5-quick-sort">Vorlesung 5 - Quick-Sort</h2>
<ul>
<li>Vergleich Insertion-Sort (<script type="math/tex">O(n^2)</script>) und Merge-Sort (<script type="math/tex">O(n log n)): Bei \(2^{14}</script> Elementen ist Merge-Sort 100x schneller, bei 1 Mio. Elementen ist es 6'400x schneller</li>
<li>Insertion Sort würde für 1 Mio. Elemente ca. 1h 47' benötigen, merge-Sort nur einige Sekunden</li>
</ul>
<h3 id="quick-sort">Quick-Sort</h3>
<ul>
<li>Partitionierung in 3 Mengen: Less, Equal und Greater mit einem Pivot x<ul>
<li>Jedes Element in die richtige Menge kopieren -&gt; <script type="math/tex">O(n)</script>
</li>
</ul>
</li>
<li>Rekursiver Aufruf mit L und G</li>
<li>Zusammensetzen: L, E, G hintereinander wieder einfügen</li>
</ul>
<p><img alt="Vergleich Sortieralgorithmen" src="../img/quicksort_tree.png" /></p>
<ul>
<li>Wenn der Pivot immer das minimum oder maximum ist, gibt es einen einseitigen "tree", d.h Worst-Case ist <script type="math/tex">O(n^2)</script>
</li>
<li>Der optimale Pivot wäre der mittlere Wert</li>
<li>Wenn die Daten normalverteilt sind, gibt es zu 50% "bad-calls" bei zufälliger Wahl des Pivots (1. und 4. Viertel)</li>
<li>Erwartet wird ein Baum mit Höhe <script type="math/tex">log n</script>. Jedes Level benötigt <script type="math/tex">O(n)</script>, also total <script type="math/tex">O(n log n)</script>
</li>
<li>In-Place Quicksort<ul>
<li>Worst-Case: Wenn die Liste bereits sortiert ist</li>
</ul>
</li>
</ul>
<h3 id="sorting-lower-bound">Sorting Lower Bound</h3>
<ul>
<li>Jede Permutation von Daten zeigt einen Pfad durch den Entscheidungsbaum</li>
<li>Das gibt n! Permutationen, also ist die Höhe des Baumes log(n!)
<script type="math/tex; mode=display">n^n > n! > {\frac n2}^{\frac n2}</script>
</li>
<li>Die Untere Grenze für <em>Vergleichs</em>algorithmen ist <script type="math/tex">O(n log(n))</script>
</li>
</ul>
<h3 id="bucket-sort">Bucket-Sort</h3>
<ul>
<li>Eine Sequenz mit Key-Value-Paaren</li>
<li>Jedes Item in ein Array mit dem Key als Index kopieren<ul>
<li>Genauer ein Array von Listen, Elemente mit gleichem Key werden der Liste angehängt</li>
</ul>
</li>
<li>Array durch iterieren und der Reihe nach ausgeben</li>
<li>Laufzeit: <script type="math/tex">O(n + N)</script>, wobei N der grösstmögliche Wert der Keys ist<ul>
<li>Kein Widerspruch zu oben, weil Algorithmus nicht vergleichs-basiert ist</li>
</ul>
</li>
<li>Eingeschränkt auf ganze, positive Zahlen</li>
<li><em>Stabile</em> Sort-Eigenschaft: die relative Ordnung von Items mit gleichem Wert wird nicht verändert</li>
</ul>
<hr />
<h2 id="vorlesung-6-radix-sort-pattern-matching">Vorlesung 6 - Radix-Sort / Pattern Matching</h2>
<h3 id="lexikographische-sortierung">Lexikographische Sortierung</h3>
<ul>
<li>Die letzte Dimension wird <em>zuletzt</em> sortiert, d.h die Dimension mit 1. Priorität am Schluss</li>
<li>Einfachste Anwendung ist mit Strings</li>
<li>Radix-Sort<ul>
<li>Lexikographische Sortierung mit Bucket-Sort</li>
</ul>
</li>
</ul>
<h3 id="pattern-matching">Pattern Matching</h3>
<ul>
<li>Ziel: In einer Sequenz von Zeichen ein Pattern finden</li>
<li>Substring wird hier inklusive end-index angegeben. In Java geht der Substring bis endIndex - 1!</li>
<li>Brute-Force-Methode<ul>
<li>Pattern am Anfang des Textes ansetzen und Zeichen für Zeichen durchlaufen bis zum Ende</li>
<li>Bei jeder Iteration prüfen, ob das Pattern übereinstimmt</li>
<li>Performance: Pattern m n Mal durchsuchen -&gt; <script type="math/tex">O(n\cdot m)</script>
</li>
</ul>
</li>
<li>Boyer-Moore Heuristik<ul>
<li>"Looking Glass": Starte jeweils am Ende des Patterns</li>
<li>"Character Jump": Bei einem Mismatch wird mit dem Pattern an die nächstmögliche Position gesprungen, wo das Zeichen im Text im Pattern vorkommt (wenn nicht, kann es gleich weiter geschoben werden um ganze Patternlänge)<ul>
<li>Es muss zwinged auf das letzt auftretende (möglichst weit rechte) Zeichen ausgerichtet werden</li>
<li>Wenn man dabei nach links schieben würde, wird stattdessen um 1 nach rechts geschoben</li>
</ul>
</li>
<li>Die Last Occurence Funktion speichert von jedem zeichen im Alphabet die letzte Position im Pattern (wenn es nicht vorkommt, -1)</li>
<li>Damit kann mit \O(1)) die Anzahl der Verschiebungen berechnet werden</li>
<li>Performance: Im Worst Case <script type="math/tex">O(n\cdot m + s)</script>, also schlechter als Brute Force. Im Durchschnitt ist er aber sehr schnell für Textanalysen</li>
</ul>
</li>
<li>KMP Algorithmus<ul>
<li>Sucht Suffixe, die auch Präfixe vom Pattern sind</li>
<li>So werden nach dem Verschieben nach rechts redundante Vergleiche vermieden</li>
</ul>
</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../reing/" class="btn btn-neutral float-right" title="ReIng">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../.." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/Excape/hsr-docs-hs16" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../.." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../reing/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../../js/theme.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>

</body>
</html>
